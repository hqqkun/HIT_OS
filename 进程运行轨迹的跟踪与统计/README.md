# 进程运行轨迹的跟踪与统计

## 1	前言

### 1.1	进程运行状态

```c
/* 在 include/linux/sched.h 中定义 */

#define TASK_RUNNING		0
#define TASK_INTERRUPTIBLE	1
#define TASK_UNINTERRUPTIBLE	2
#define TASK_ZOMBIE		3
#define TASK_STOPPED		4
```

|        进程状态        |       含义       |                             注释                             |
| :--------------------: | :--------------: | :----------------------------------------------------------: |
|     *TASK_RUNNING*     | 正在执行或就绪态     |           进程可以在内核态运行，也可在用户态运行。           |
|  *TASK_INTERRUPTIBLE*  |  可中断睡眠状态  | 系统不会调度该进程，当系统产生中断或释放该进程所等待的资源，或进程收到信号，进程都可以被唤醒，进入就绪态 |
| *TASK_UNINTERRUPTIBLE* | 不可中断睡眠状态 | 与前者相似，但该状态的进程只有被 *wake_up()* 函数明确唤醒时，才能进入就绪态。 |
|     *TASK_ZOMBIE*      |     僵死状态     | 当进程已停止运行，但其父进程还没有询问其状态时，该进程处于僵死状态。 |
|     *TASK_STOPPED*     |     暂停状态     | 当进程收到信号 *SIGSTOP*、*SIGTSTP*、*SIGTTIN*、*SIGTTOU* 时会进入暂停状态。向其发送 *SIGCONT* 信号可让该进程转为就绪态。但在 *Linux 0.11* 上未实现该转换，因此处于该状态的进程被视为终止进程。 |



## 2	实验内容

进程从创建（`Linux` 下调用 fork()）到结束的整个过程就是进程的生命期，进程在其生命期中的运行轨迹实际上就表现为进程状态的多次切换，如进程创建以后会成为就绪态；当该进程被调度以后会切换到运行态；在运行的过程中如果启动了一个文件读写操作，操作系统会将该进程切换到阻塞态（等待态）从而让出 CPU；当文件读写完毕以后，操作系统会在将其切换成就绪态，等待进程调度算法来调度该进程执行……

