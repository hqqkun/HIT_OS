# 8086 汇编快速教程

假定读者了解程序设计（C 语言）、数据结构和一些计算机组成的知识。

且本教程只是“泛泛而谈”，仅为衔接 `Linux 0.11` 有关汇编语言的部分。

## 1	寄存器

由于 8086 为 16 位寄存器，所以字长为 16位，也就是两个字节。

### 1.1	通用寄存器

通用寄存器（General Purpose Register），用于传送和暂存数据，也可参与算术逻辑运算，及保存运算结果。然而其中一些寄存器有其特殊用途。

8086 共有 8 个通用寄存器，`ax` 、`bx` 、`cx` 、`dx` 、`bp` 、`sp` 、`si` 、`di` 。 前四个用作数据寄存器：

| 寄存器 |                             功能                             |
| :----: | :----------------------------------------------------------: |
|  *AX*  |                   累加器（*Accumulator*）                    |
|  *BX*  | 基址（*Base*），常用作基址寄存器，如数组的首地址，默认为数据段寻址（1.2 讲述） |
|  *CX*  |                计数（*Count*），常用在循环内                 |
|  *DX*  |         数据（*Data*），可以与 *AX* 组合形成双字长数         |
|  *BP*  | 基址（*Base Pointer*），与 *BX* 不同在于默认在栈内寻址（1.2 讲述） |
|  *SP*  |         栈指针（*Stack Pointer*），指向当前栈顶元素          |
|  *SI*  |                   源地址（*Source Index*）                   |
|  *DI*  |               目的地址（*Destination Index*）                |

`bp` 、 `sp` 常常一起使用，寻址栈内地址。`si` 、`di` 同样用于段内寻址。

***

### 1.2	段寄存器

C/C++ 所编写的程序有代码区、静态存储区、常量区、堆区和栈区。静态存储区放置全局变量和静态局部变量（`static` 修饰）。可以如此理解汇编语言里的段寄存器。

8086 有 4 个段寄存器，均 16 位，`cs` 、`ds` 、`es` 、`ss` 。

| 寄存器 |            功能            |
| :----: | :------------------------: |
|  *CS*  |           代码区           |
|  *DS*  | 数据区（静态存储，常量区） |
|  *ES*  |            扩展            |
|  *SS*  |            栈区            |

8086 有一个指令指针寄存器 `ip`（Instruction Pointer，在计算机组成里叫做 pc，Program Counter）。其也是 16 位。但若这样寻址，只能使用 2<sup>16</sup> B（若内存按字节寻址），也就是 `64 KB` 的地址空间，远远不够。同时，因为有段的限制，也不允许直接使用 ip 进行寻址，否则可能会将数据区甚至是栈区当作代码进行执行。

因此 8086 规定，必须将 `cs` 与 `ip` 结合使用。但又不能简单相加，否则还是只能寻址 `64 KB` 。所以规定：

```C
/* CS 为代码段的段基址 */
/* 通常在文档中写作 PC = CS:IP，表示左移并相加 */

PC = CS << 4 + IP
```

将生成的 `PC` 作为地址，这样就可以寻址 20 位，为 `1MB` 。 同理其他寄存器：`DS:SI`、`ES:DI`、`SS:SP` 。

***

### 1.3	标志寄存器

FR（Flag Register），也是 16 位。它在 32 位体系中通常称作 `eflags` 。

|  15  |  14  |  13  |  12  |  11  |  10  |  9   |  8   |  7   |  6   |  5   |  4   |  3   |  2   |  1   |  0   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |      |      |      | *OF* | *DF* | *IF* | *TF* | *SF* | *ZF* |      | *AF* |      | *PF* |      | *CF* |

其余空着的位在 8086 中并没有使用。

| 标志 |                             含义                             |
| :--: | :----------------------------------------------------------: |
| *CF* | 进位标志位（*Carry Flag*），若无符号运算，最高位产生进位或借位，置位。 |
| *PF* | 奇偶标志位（*Parity Flag*），若指令结果 1 的个数为偶数，则置位。 |
| *AF* | 辅助进位标志位（*Assistent Carry Flag*），若最后四位向前有进位或者借位，则置位。 |
| *ZF* |       零标志位（*Zero Flag*），若指令结果为 0 ，置位。       |
| *SF* |      符号标志位（*Sign Flag*），若指令结果为负，置位。       |
| *TF* | 陷入标志位（*Trap Flag*），若为 1 则产生单步中断，引发中断过程。 |
| *IF* |   中断标志位（*Interruptable Flag*），当允许中断时，置位。   |
| *DF* |       方向标志位（*Direction Flag*），串传送指令使用。       |
| *OF* | 溢出标志位（*Overflow Flag*），当有符号运算结果溢出，置位。  |

***

## 2	常用指令

以下均假定 `int` 为两个字节。

### 2.1	MOV 

```assembly
/* 8086 Intel 写法都是 A 为目的操作数，与 AT&T 相反 */
/* 表示数据从 B（寄存器或立即数） 移入 A */
	mov A,B
/* 表示数据从 ss:bp（主存单元） 移入 A */
	mov A,[bp]
```

若用 `R` 表示寄存器（`Register`），`M` 表示主存（`Memory`），`I` 表示立即数（`Immediate`）。则实际有 4 种可能：

| 方式（A,B） |
| :---------: |
|    *R-R*    |
|    *R-M*    |
|    *M-R*    |
|    *R-I*    |

例如：

```c
{
	int temp;
	temp = 6;
}
```

上面 C 代码可被编译为：

```assembly
/* 假设变量 temp 被编译器优化，放到寄存器 dx */
	mov dx,6
```

***

### 2.2	ADD 和 SUB

这个略，就是很容易理解的加法、减法。现代常用加法来代替减法操作。

***

### 2.3	PUSH 和 POP

与数据结构知识一样，`push` 指压栈，`pop` 指弹栈。栈底为高地址，栈顶为低地址，所以压栈的时候 `sp` 要减小。

```assembly
	push ax
	
	/* 等价于 */
	add sp,-4
	mov ss:[sp],ax
```

同理：

```assembly
	pop ax
	
	/* 等价于 */
	mov ax,ss:[sp]
	add sp,4
```

***

### 2.4	LOOP

```C
	for(int i = 4; i; --i){
        /* …… */
    }
```

上段代码可编译为 `loop` 语句：

```assembly
	mov cx,4
foo:
	/* …… */
	loop foo
```

`loop` 指令的格式为：`loop，标号` 。执行 `loop` 时要进行两步操作：

1）cx = cx - 1;

2）判断 cx 的值，若为 0 则向下执行，否则跳转到标号位置执行。

`loop` 指令必须使用 `cx` 。

***



### 2.5	JMP

`jmp` 指令的格式为：`jmp，标号` 。与 `loop` 相似，只是不做检查，所以是无条件转移。

```C
	for(;;){
    	/* …… */
	}
	/* 或 */

	while(1){
        /* …… */
    }
```

可被编译为：

```assembly
foo:
	/* …… */
	jmp foo
```

***

### 2.6	CALL 和 RET

编程不能一条道写到黑，往往要进行模块化程序设计。这就是函数的作用，C 语言里写的任何函数同样可以被编译为汇编的函数体：

```C
#include <stdio.h>

int main(void)
{
    printf("hello world.");
    return 0;
}
```

汇编代码：

```assembly
main:
	/* 向 printf 传递参数 */
	call printf
	/* 后续处理 */
```

`call` 的作用就是调用函数，调用以后回到下一句代码处继续执行。那么如何操作能回到调用的下一句（也就是断点）执行呢？显然在函数体内部是无法做到的，那么肯定是 `call` 本身起作用。执行 `call` 指令时的操作：

1）`push ip`

2）`jmp printf` 

首先将下一条指令地址压栈，然后无条件转移至函数体。这样当函数体执行完毕时，从栈中弹出地址放入 ip 即可。函数可以有很多参数，甚至有些函数例如 `printf` 不知道参数有多少个，那么怎么向函数体传递参数呢？

汇编采用的方法同样是压栈，因为这样可以很方便的找到参数：

```C
/* 若调用 foo() */

int foo(int x,int y,int z)
{
    /* …… */
    return 0;
}
```

```assembly
/* 为方便讲解，假定 x,y,z 被编译器优化，分别放在 ax, bx, cx 内 */

	push cx
	push bx
	push ax
	call foo

foo:
	/* …… */
	mov ax,0
	ret
```

这里为什么从后向前传递呢，即先传递 `z` ，最后是 `x` 。可以观察下执行 `call foo` 之后栈的结构：

| 栈位置 | 栈内值 |
| :----: | :----: |
|   高   |   z    |
|        |   y    |
|        |   x    |
|   低   |  断点  |

这样的结构很容易找到第一个参数，因为返回地址的上面就是第一个参数，随后是第二个参数。因此，向栈传递参数都是从后向前。

下面说 `ret` ，函数执行完毕后会返回，就像我们都会写 `return 0` 一样。8086 汇编，返回值会放在 `ax` 寄存器内。`return 0` 的含义在这里就是 `mov ax,0` ,函数在碰到右大括号（`}`）时才会执行 `ret` 指令，效果就是从栈内弹出一个地址放入 `ip` ，随后程序就会在调用函数的下一句继续执行了。

***

### 2.7	INT

不论是程序运行错误（除 0）或者使用 BIOS 功能，我们都会用到中断。`int` 指令（interrupt）就是执行中断指令，当然这里是软中断。

当我们讨论 8086 的汇编时，在内存的 `0 ~ 0x3ff` 处放着一张中断向量表，可以存放 `256` 个向量地址，即每个向量地址占 `4B` ，分别是 `IP`、`CS` ：

| 地址 |     数值      |
| :--: | :-----------: |
|  0   | *int 0（ip）* |
|  2   | *int 0（cs）* |
|  4   | *int 1（ip）* |
|  6   | *int 1（cs）* |



如下是 `BIOS 0x10` 中断的一个子程序功能：

|     功能     | 子程序编号 |   参数    |                          返回值                          |
| :----------: | :--------: | :-------: | :------------------------------------------------------: |
| 读取光标位置 | AH = 0x03  | BH = 页号 | AX = 0，CH = 光标开始行，CL = 光标结束行，DH = 行，DL=列 |

```assembly
	mov	ah,3		! 读取光标位置
	xor	bh,bh		! 异或运算，将 bh 清零
	int	0x10
```

就是这样简单的指令，就可以读取屏幕光标的位置。那么 `int` 指令怎么执行？学过计算机组成原理的读者肯定知道：

1）关中断

2）保存断点

3）形成中断服务程序的入口地址

`int` 执行其实也是一种函数调用，只不过这种调用屏蔽了细节。`int` 也做上面三件事：

```assembly
	/* 
	 * 以下仅为 int n 的指令示意，实际上这些指令都是隐指令，含在 int 里
	 * 日常使用时，这些指令绝不可能编译成功
	 */
	
	/* 1）标志寄存器压栈，同时将该寄存器的 IF 和 TF 位，置零 */
	push FR
	
	/* 2）压栈顺序：先 cs 后 ip）*/
	push cs
	push ip

	/* 3）形成入口地址，为什么乘 4 ，是因为每个向量占 4B，具体请看上方表格 */
	mov ip,n * 4
	mov cs,n * 4 + 2
```

***

## 3	简单的交换程序（C语言）



```C
/* 交换 *x 与 *y */

void swap(int* x, int* y)
{
    int tmp = *x;
    *x = *y;
    *y = tmp;
}
```

### 3.1	编译成汇编代码

可以编译成 `8086` 汇编，（我自己写的）

```assembly
	! 我没有考虑调用者保存或被调用者保存的问题，只是简单的把用到的寄存器都保存
	! 假定 int 为 2B 
swap:
	! 未优化
	push bp
	mov bp,sp
	push ax
	push bx
	push cx
	push si

	add sp,-2			! tmp 
	mov bx,4[bp]		! bx = x
	mov si,6[bp]		! si = y
	mov ax,ss:[bx]		! ax = *x

	mov -10[bp],ax		! tmp = *x

	mov cx,ss:[si]		
	mov ss:[bx],cx		! *x = *y

	mov ax,-10[bp]
	mov ss:[si],ax		! *y = tmp

	add sp,2
	pop si
	pop cx
	pop bx
	pop ax
	pop bp

	ret
```

上面的汇编代码，我只是简单按照 `swap()` 程序内部框架所编译。可以看到，`add sp,-2` 的目的是放置临时变量 `tmp` 。聪明的读者可以立刻看到，这个 `tmp` 变量有些多余，只用 `ax` 表示 `*x` 就已经够用了。

所以，优化的代码如下：

```assembly
swap:
	! 省略 push，与上段代码一致，这里只考虑 mov

	mov bx,4[bp]		! bx = x
	mov si,6[bp]		! si = y
	mov ax,ss:[bx]		! ax = *x

	mov cx,ss:[si]		
	mov ss:[bx],cx		! *x = *y
	
	mov ss:[si],ax		! *y = ax
	
	! 省略 pop 
	ret
```

***

### 3.2	加上 main

```C
void swap(int* x, int* y)
{
    int tmp = *x;
    *x = *y;
    *y = tmp;
}

int main(void)
{
    /* 局部变量，放在栈内 */
    int x = 1;
    int y = 2;
    swap(&x,&y);
    return 0;
}
```



```assembly
main:
	push dx
	
	push bp
	mov bp,sp
	add sp,-4
	
	mov -2[bp],1	! x = 1
	mov -4[bp],2	! y = 2
	
	lea dx,-4[bp]	! 向 swap() 传递参数
	push dx	        ! 若向函数传递指针，则使用 lea 指令，这里不再说明其用法
	lea dx,-2[bp]
	push dx
	call swap
	
	add sp,8
	pop bp
	pop dx
	
	mov ax,0
	ret
```

